class Position {
  x
  y
  constructor(x, y) {
    this.x = x
    this.y = y
  }

  getX() {
    return this.x
  }
  getY() {
    return this.y
  }
}

class TicTacToeBoard {
  boardValues
  DEFAULT_BOARD_SIZE = 3;
  IN_PROGRESS = -1;
  DRAW = 0;
  P1 = 1;
  P2 = 2;
  totalMoves = 0;

  constructor(board) {
    if (board) {
      this.boardValues = board.boardValues.map(r => r.slice())
      this.DEFAULT_BOARD_SIZE = board.DEFAULT_BOARD_SIZE
      this.IN_PROGRESS = board.IN_PROGRESS
      this.DRAW = board.DRAW
      this.P1 = board.P1
      this.P2 = board.P2
      this.totalMoves = board.totalMoves
    }
    else {
      this.boardValues = [[0, 0, 0], [0, 0, 0], [0, 0, 0]]
      this.DEFAULT_BOARD_SIZE = 3
      this.IN_PROGRESS = -1
      this.DRAW = 0
      this.P1 = 1
      this.P2 = 2
      this.totalMoves = 0
    }
  }

  performMove(player, p) { // position p
    this.totalMoves++;
    this.boardValues[p.getX()][p.getY()] = player;
  }

  checkStatus() {
    /* Evaluate whether the game is won and return winner. If it is draw return 0 else return -1 */
    const { boardValues: b, totalMoves } = this

    if (b[0][0] !== 0 && b[0][0] === b[0][1] && b[0][1] === b[0][2]) {
      return b[0][0]
    } else if (b[1][0] !== 0 && b[1][0] === b[1][1] && b[1][1] === b[1][2]) {
      return b[1][0]
    } else if (b[2][0] !== 0 && b[2][0] === b[2][1] && b[2][1] === b[2][2]) {
      return b[2][0]
    } else if (b[0][0] !== 0 && b[0][0] === b[1][0] && b[1][0] === b[2][0]) {
      return b[1][0]
    } else if (b[0][1] !== 0 && b[0][1] === b[1][1] && b[1][1] === b[2][1]) {
      return b[0][1]
    } else if (b[0][2] !== 0 && b[0][2] === b[1][2] && b[1][2] === b[2][2]) {
      return b[0][2]
    } else if (b[0][0] !== 0 && b[0][0] === b[1][1] && b[1][1] === b[2][2]) {
      return b[0][0]
    } else if (b[0][2] !== 0 && b[0][2] === b[1][1] && b[1][1] === b[2][0]) {
      return b[0][2]
    }

    if (totalMoves === 9) {
      return 0
    }

    return -1
  }

  getEmptyPositions() {
    const size = this.boardValues.length;
    const emptyPositions = new Array();
    for (let i = 0; i < size; i++) {
      for (let j = 0; j < size; j++) {
        if (this.boardValues[i][j] == 0)
          emptyPositions.push(new Position(i, j));
      }
    }
    return emptyPositions;
  }
}


class UTTTBoard {
  boardValues
  DEFAULT_BOARD_SIZE = 9;
  IN_PROGRESS = -1;
  DRAW = 0;
  P1 = 1;
  P2 = 2;
  totalMoves = 0;
  unlockedBoardCell = -1
  wonBoards = [[-1, -1, -1], [-1, -1, -1], [-1, -1, -1]] // 2d array to match original checkStatus() spec

  constructor(board) {
    if (board) {
      console.log('board:', board)
      this.boardValues = board.boardValues.slice()
      this.wonBoards = board.wonBoards.map(r => r.slice())
      this.unlockedBoardCell = board.unlockedBoardCell
      this.totalMoves = board.totalMoves
    }
    else {
      this.boardValues = '0'.repeat(81).split('').map((x) => parseInt(x))
    }
  }

  performMove(player, index) {
    this.totalMoves++;
    this.boardValues[index] = player

    const boardIndex = Math.floor(index / 9)
    const start_i = boardIndex * 9
    const currBoard = [
      this.boardValues.slice(start_i, start_i + 3),
      this.boardValues.slice(start_i + 3, start_i + 6),
      this.boardValues.slice(start_i + 6, start_i + 9)
    ]

    // Updates won boards if the status of the board in the current move has changed.
    const status = this.checkStatus(currBoard)

    if (status !== -1) {
      debugger
      flattenNestedArrays(this.wonBoards)[boardIndex] = status
    }

    // Updates unlocked board cell, if the board is already won then sets unlockedBoardCell to -1
    const localMoveIndex = index % 9
    const nextBoardStatus = this.wonBoards[Math.floor(boardIndex / 3)][boardIndex % 3]
    this.unlockedBoardCell = (nextBoardStatus === -1) ? localMoveIndex : -1
  }
  /*
    Evaluates whether the global board has been won by default, can also evaluate if the unlocked board has been won.
    Returns the winner, if it's a draw then 1 else -1.
  */
  checkStatus(board) {
    /* Evaluate whether the game is won and return winner. If it is draw return 0 else return -1 */
    const b = board ? board : this.wonBoards
    console.log('checking status of: ', b)
    if (b[0][0] !== 0 && b[0][0] === b[0][1] && b[0][1] === b[0][2]) {
      return b[0][0]
    } else if (b[1][0] !== 0 && b[1][0] === b[1][1] && b[1][1] === b[1][2]) {
      return b[1][0]
    } else if (b[2][0] !== 0 && b[2][0] === b[2][1] && b[2][1] === b[2][2]) {
      return b[2][0]
    } else if (b[0][0] !== 0 && b[0][0] === b[1][0] && b[1][0] === b[2][0]) {
      return b[1][0]
    } else if (b[0][1] !== 0 && b[0][1] === b[1][1] && b[1][1] === b[2][1]) {
      return b[0][1]
    } else if (b[0][2] !== 0 && b[0][2] === b[1][2] && b[1][2] === b[2][2]) {
      return b[0][2]
    } else if (b[0][0] !== 0 && b[0][0] === b[1][1] && b[1][1] === b[2][2]) {
      return b[0][0]
    } else if (b[0][2] !== 0 && b[0][2] === b[1][1] && b[1][1] === b[2][0]) {
      return b[0][2]
    }

    return -1
  }

  // gets all valid moves, not all empty positions
  getEmptyPositions() {

    let min = 0
    let max = 80
    if (this.unlockedBoardCell >= 0) {
      min = this.unlockedBoardCell * 9
      max = this.unlockedBoardCell * 9 + 9
    }
    debugger
    const emptyPositions = new Array();
    for (let i = min; i < max; i++) {
      if (this.boardValues[i] === 0 && flattenNestedArrays(this.wonBoards)[Math.floor(i / 9)] === -1) {
        emptyPositions.push(i)
      }
    }
    return emptyPositions;
  }
}

function flattenNestedArrays(arr) {
  return [].concat.apply([], arr);
}


export {
  TicTacToeBoard,
  UTTTBoard,
  Position
}