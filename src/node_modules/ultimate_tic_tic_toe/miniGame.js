class Node {
  state
  parent
  childArray
  
  constructor(dynamicInitializer) {

    const initializingFromNothing = !dynamicInitializer

    if (initializingFromNothing) {
      this.state = new State()
      this.parent = null
      this.childArray = []
      return 
    }

    const initializingFromNode = dynamicInitializer.state
    const initializingFromState = !initializingFromNode

    if (initializingFromNode) {
      this.state = dynamicInitializer.state
      this.parent = dynamicInitializer.parent
      this.childArray = dynamicInitializer.childArray
    } else if (initializingFromState) {
      this.state = dynamicInitializer
    }
  }

  getState() {
    return this.state
  }

  getParent(){
    return this.parent
  }
  
  getChildArray() {
    return this.childArray
  }

  setBoard(board) {
    this.state.setBoard(board)
  }

  setPlayerNo(playerNo) {
    this.state.setPlayerNo(playerNo)
  }

  getChildWithMaxScore(){
    let maxScore = Number.MIN_SAFE_INTEGER
    let child
    this.childArray.forEach(c => {
      if (c.state.winScore > maxScore) {
        maxScore = c.state.winScore
        child = c
      }
    })
    return child
  }
}

class Tree {
  root;

  constructor(n) {
    if (n) this.root = n
    else {
      this.root = new Node()
    }
  }
  getRoot() {
    return this.root
  }
  setRoot(node) {
    this.root = node
  }
}

class State {
  board;
  playerNo;
  visitCount;
  winScore;

  constructor(state){
    this.board = state ? state.board : null
    this.playerNo = state ? state.playerNo : null
    this.visitCount = state ? state.visitCount : 0
    this.winScore = state ? state.winScore : null
  }

  getBoard(){
    return this.board
  }
  setBoard(board){
    this.board = board
  }
  setPlayerNo(player) {
    this.playerNo = player
  }
  getAllPossibleStates() {
    // constructs a list of all possible states from current state
  }
  randomPlay() {
    /* get a list of all possible positions on the board and 
       play a random move */
  }
}

class MonteCarloTreeSearch {
  static WIN_SCORE = 10
  level
  opponent

  findNextMove(board, playerNo) {
    // define an end time which will act as a terminating condition
    const end = (new Date()).getTime() + 5000

    this.opponent = 3 - playerNo;
    let tree = new Tree();
    debugger
    const rootNode = tree.getRoot();
    rootNode.getState().setBoard(board);
    rootNode.getState().setPlayerNo(this.opponent);

    while ((new Date()).getTime() < end) {
      let promisingNode = selectPromisingNode(rootNode);
      if (promisingNode.getState().getBoard().checkStatus()
        == Board.IN_PROGRESS) {
        expandNode(promisingNode);
      }
      let nodeToExplore = promisingNode;
      if (promisingNode.getChildArray().length > 0) {
        nodeToExplore = promisingNode.getRandomChildNode();
      }
      const playoutResult = simulateRandomPlayout(nodeToExplore);
      backPropogation(nodeToExplore, playoutResult);
    }

    const winnerNode = rootNode.getChildWithMaxScore();
    tree.setRoot(winnerNode);
    return winnerNode.getState().getBoard();
  }
}


function selectPromisingNode(rootNode) {
  let node = rootNode;
  while (node.getChildArray().length != 0) {
    node = UCT.findBestNodeWithUCT(node);
  }
  return node;
}

class UCT {
  uctValue(totalVisit, nodeWinScore, nodeVisit) {
    if (nodeVisit == 0) {
      return Number.MAX_SAFE_INTEGER;
    }
    return (nodeWinScore / nodeVisit)
      + 1.41 * Math.sqrt(Math.log(totalVisit) / nodeVisit);
  }

  findBestNodeWithUCT(node) {
    let parentVisit = node.getState().getVisitCount()
    return Math.max(
      node.getChildArray()
      .map(c => this.uctValue(parentVisit, c.getState().getWinScore(), c.getState().getVisitCount())))
  }
}

function expandNode(node) {
  const possibleStates = node.getState().getAllPossibleStates()
  possibleStates.forEach(state => {
      const newNode = new Node(state)
      newNode.setParent(node)
      newNode.getState().setPlayerNo(node.getState().getOpponent())
      node.getChildArray().add(newNode)
  });
}

function backPropogation(nodeToExplore, playerNo) {
  let tempNode = nodeToExplore;
  while (tempNode != null) {
      tempNode.getState().incrementVisit();
      if (tempNode.getState().getPlayerNo() == playerNo) {
          tempNode.getState().addScore(this.WIN_SCORE);
      }
      tempNode = tempNode.getParent();
  }
}
function simulateRandomPlayout(node) {
  let tempNode = new Node(node);
  let tempState = tempNode.getState();
  let boardStatus = tempState.getBoard().checkStatus();
  if (boardStatus == this.opponent) {
      tempNode.getParent().getState().setWinScore(Number.MIN_SAFE_INTEGER);
      return boardStatus;
  }
  while (boardStatus == Board.IN_PROGRESS) {
      tempState.togglePlayer();
      tempState.randomPlay();
      boardStatus = tempState.getBoard().checkStatus();
  }
  return boardStatus;
}


class Position {
  x
  y
  constructor(x, y) {
    this.x = x
    this.y = y
  }

  getX(){
    return this.x
  }
  getY(){
    return this.y
  }
}
class Board {
  boardValues
  DEFAULT_BOARD_SIZE = 3;
  IN_PROGRESS = -1;
  DRAW = 0;
  P1 = 1;
  P2 = 2;
  totalMoves = 0;
   
  // getters and setters
  performMove(player, p) { // position p
      this.totalMoves++;
      this.boardValues[p.getX()][p.getY()] = player;
  }

  checkStatus() {
      /* Evaluate whether the game is won and return winner.
         If it is draw return 0 else return -1 */    
    let newhis = this
    debugger
  }

  getEmptyPositions() {
      const size = this.boardValues.length;
      const emptyPositions = new Array();
      for (let i = 0; i < size; i++) {
          for (let j = 0; j < size; j++) {
              if (this.boardValues[i][j] == 0)
                  emptyPositions.add(new Position(i, j));
          }
      }
      return emptyPositions;
  }
}



function runGame() {
  let mtcs = new MonteCarloTreeSearch()
  let board = new Board();
  let player = board.P1;
  let totalMoves = board.DEFAULT_BOARD_SIZE * board.DEFAULT_BOARD_SIZE;
  for (let i = 0; i < totalMoves; i++) {
      board = mtcs.findNextMove(board, player);
      if (board.checkStatus() != -1) {
          break;
      }
      player = 3 - player;
  }
  let winStatus = board.checkStatus();
  debugger
  console.log(winStatus === board.DRAW)
  // assertEquals(winStatus, Board.DRAW);
}

export {
  runGame
}