const PLAYER_ONE = 1
const PLAYER_TWO = 2
const EMPTY = 0

class Game {
  board = []

  constructor() {
    this.board = '0'.repeat(81).split('').map((x) => parseInt(x))
    this.wonBoards = '0'.repeat(9).split('').map((x) => parseInt(x))
    this.turn = PLAYER_ONE
    this.unlockedBoard = -1
    this.gameOver = false
    this.winningPlayer = null
    this.moveCount = 0
    // this.load()
  }

//   load(){
//     this.board = []
//     for (let i = 0; i < 81; ++i) {
//       this.board.push(0)
//     }
//   }

  getWinningPlayer(){
    return this.winningPlayer
  }
  move(index) {
    if (typeof index !== 'number')
      throw new Error('Incorrect argument provided to move method.')
    const boardIndex = Math.floor(index / 9)

    if (this.isGameOver()) {
      throw new Error("Invalid move: game is already over.")
    } else if (this.wonBoards[boardIndex] !== 0) {
      throw new Error("Invalid move: this board has already been won.")
    }


    const newBoard = this.board.slice()
    const turn = this.turn
    newBoard[index] = turn

    const newTurn = turn === PLAYER_ONE ? PLAYER_TWO : PLAYER_ONE;
    const newWonBoards = this.getWonBoards({ board: newBoard, index, turn })

    const sum = (listOfNumbers) => listOfNumbers.reduce((a, b) => a + b, 0)

    // Finds next unlocked board, if that board has no available moves then all boards become unlocked.
    let unlockedBoard = sum(newWonBoards) !== sum(this.wonBoards) || newWonBoards[index % 9] > 0 ? -1 : index % 9

    let movesAvailable = false
    for (let i = unlockedBoard * 9; i < unlockedBoard * 9 + 9; ++i) {
      if (this.board[i] === 0) {
        movesAvailable = true
      }
    }

    if (!movesAvailable) {
      unlockedBoard = -1
    }

    this.board = newBoard,
    this.turn = newTurn,
    this.unlockedBoard = unlockedBoard,
    this.wonBoards = newWonBoards
    this.checkIfGameOver()
    this.moveCount++
    return true
  }
  checkIfGameOver(board) {
    const wonBoards = !board ? this.wonBoards : board

    if ((wonBoards[0] === wonBoards[1] && wonBoards[0] === wonBoards[2] && wonBoards[0] !== EMPTY) ||
        (wonBoards[3] === wonBoards[4] && wonBoards[3] === wonBoards[5] && wonBoards[3] !== EMPTY) ||
        (wonBoards[6] === wonBoards[7] && wonBoards[6] === wonBoards[8] && wonBoards[6] !== EMPTY) ||
        (wonBoards[0] === wonBoards[3] && wonBoards[0] === wonBoards[6] && wonBoards[0] !== EMPTY) ||
        (wonBoards[1] === wonBoards[4] && wonBoards[1] === wonBoards[7] && wonBoards[1] !== EMPTY) ||
        (wonBoards[2] === wonBoards[5] && wonBoards[2] === wonBoards[8] && wonBoards[2] !== EMPTY) ||
        (wonBoards[0] === wonBoards[4] && wonBoards[0] === wonBoards[8] && wonBoards[0] !== EMPTY) ||
        (wonBoards[2] === wonBoards[4] && wonBoards[2] === wonBoards[6] && wonBoards[2] !== EMPTY) ||
        !wonBoards.includes(0)
    ) {
      if (!board) {
        this.gameOver = true
        this.winningPlayer = !wonBoards.includes(0) ? null : this.turn === PLAYER_ONE ? PLAYER_TWO : PLAYER_ONE
      }
      return true
    }
  }
  isGameOver() {
    return this.gameOver
  }
  getBoard() {
    return this.board
  }
  getPlayerTurn() {
    return this.turn
  }
  getWonBoards({ board = null, index = null, turn = null } = {}) {
    if (!board) {
      return this.wonBoards
    }
    const boardIndex = Math.floor(index / 9) * 9
    const newWonBoards = this.wonBoards.slice()

    // Checks for wins along columns
    for (let c = 0; c < 3; ++c) {
      if (board[boardIndex + c] === board[boardIndex + c + 3] &&
        board[boardIndex + c] === board[boardIndex + c + 6] &&
        board[boardIndex + c] !== 0) {
        newWonBoards[boardIndex / 9] = turn
        return newWonBoards
      }
    }

    // Checks for wins along rows
    for (let r = 0; r < 3; ++r) {
      if (board[boardIndex + (r * 3)] === board[boardIndex + (r * 3 + 1)] &&
        board[boardIndex + (r * 3)] === board[boardIndex + (r * 3 + 2)] &&
        board[boardIndex + (r * 3)] !== 0) {
        newWonBoards[boardIndex / 9] = turn
        return newWonBoards
      }
    }

    // Checks for wins along diagonals
    if ((
      (board[boardIndex] === board[boardIndex + 4] && board[boardIndex] === board[boardIndex + 8]) ||
      (board[boardIndex + 2] === board[boardIndex + 4] && board[boardIndex + 2] === board[boardIndex + 6])
    ) &&
      board[boardIndex + 4] !== 0
    ) {
      newWonBoards[boardIndex / 9] = turn
      return newWonBoards
    }

    // Checks if board has any moves available
    let movesAvailable = false
    for (let i = boardIndex; i < boardIndex + 9; ++i) {
      if (board[i] === 0) {
        movesAvailable = true
      }
    }

    if (!movesAvailable) {
      newWonBoards[boardIndex / 9] = -1
    }

    return newWonBoards
  }

  getMoves() {
    let min = 0
    let max = 80
    if (this.unlockedBoard >= 0) {
      min = this.unlockedBoard * 9
      max = this.unlockedBoard * 9 + 9
    }

    const moves = []
    for (let i = min; i <= max; ++i) {
      if (this.board[i] === 0 && this.wonBoards[Math.floor(i / 9)] === 0) {
        moves.push(i)
      }
    }
    return moves
  }
  getUnlockedBoard() {
    return this.unlockedBoard
  }

  print() {
    const rows = ['','','','','','','','','']
    for (let r = 0; r < 9; ++r) {
      for (let c = 0; c < 9; ++c) {
        const cDest = (c < 3) ? c : (c < 6) ? (r + 1) * 9 : (r + 2) * 9

        if (this.board[cDest] === PLAYER_ONE) rows[r] += 'x'
        else if (this.board[cDest] === PLAYER_TWO) rows[r] += 'o'
        else rows[r] += '-'

        if (c === 2 || c === 5) {
          rows[r] += '|'
        }
      }
    }
    let output =  '...........' +  '\n'
    for (let i = 0; i < rows.length; ++i) {
      output += rows[i] + '\n'
      if ((i + 1) % 3 === 0) {
        output += '...........' +  '\n'
      }
    }

    return output
  }

  getMoveFromBot({skill}) {
    if (skill === 0) {
      return this.getMoveFromLevelZeroBot()
    } else if (skill === 1) {
      return this.getMoveFromLevelOneBot()
    }
  }

  // Strategy: random moves
  getMoveFromLevelZeroBot(){
    const moves = this.getMoves()
    const move = moves[Math.floor(Math.random() * moves.length)]
    return move
  }

  // Strategy: greedy moves aiming to win local grids
  getMoveFromLevelOneBot(){
    // Finds the unlocked board with the largest difference of friendly to opposing pieces.
    let unlockedBoard = this.unlockedBoard   
    let maxDiff = -1
    if (this.unlockedBoard === -1) {
      for (let i = 0; i < 9; ++i) {
        if (this.wonBoards[i] === 0) {
          const friendlyCells = this.findCellsOccupiedBy(this.turn, i).length
          const opposingCells = this.findCellsOccupiedBy(this.turn === PLAYER_ONE ? PLAYER_TWO : PLAYER_ONE, i).length
          if (friendlyCells - opposingCells > maxDiff) {
            unlockedBoard = i
            maxDiff = friendlyCells - opposingCells
          }
        }
      }
    }

    // Finds the move that creates the largest number of winning scenarios
    const moves = this.getMoves().filter((n) => n >= unlockedBoard * 9 && n < unlockedBoard * 9 + 9)
    if (moves.length === 1) return moves[0]  
  
    const miniBoard = this.board.slice(unlockedBoard, unlockedBoard + 9)
    let globalWaysToWin = -1
    let bestMove = null

    for (let i = 0; i < moves.length; ++i) {
      if (globalWaysToWin !== 100) {
        const moveMadeBoard = miniBoard.slice()
        moveMadeBoard[moves[i] % 9] = this.turn
        let localWaysToWin = 0
        
        if (this.checkIfGameOver(moveMadeBoard)) {
          return moves[i]
        } else {
          for (let j = 0; j < moves.length; ++j) {
            const nextMoveMadeBoard = moveMadeBoard.slice()
            nextMoveMadeBoard[moves[j] % 9] = this.turn
            if (this.checkIfGameOver(nextMoveMadeBoard)) localWaysToWin++
          }
          if (localWaysToWin > globalWaysToWin) {
            globalWaysToWin = localWaysToWin
            bestMove = moves[i]
          }
        }
      }
    }

    return bestMove
  }

  findCellsOccupiedBy(player, boardIndex) {
    const cells = []
    const min = boardIndex * 9
    for (let i = min; i < min + 9; ++i) {
      if (this.board[i] === player) cells.push[i]
    }
    return cells
  }

  getMoveCount() {
    return this.moveCount
  }
}
export default Game